#!/bin/bash

# CodeMate Start Script
# This script sets up and runs CodeMate in a Docker container

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;36m'
NC='\033[0m' # No Color

# Default values
GIT_REPO_URL="${GIT_REPO_URL:-$(git config --get remote.origin.url 2>/dev/null || echo '')}"
UPSTREAM_REPO_URL="${UPSTREAM_REPO_URL:-}"
BRANCH_NAME="${BRANCH_NAME:-}"
PR_NUMBER="${PR_NUMBER:-}"
PR_TITLE="${PR_TITLE:-}"
ISSUE_NUMBER="${ISSUE_NUMBER:-}"
QUERY="${QUERY:-}"
CODEMATE_IMAGE="${CODEMATE_IMAGE:-ghcr.io/boringhappy/codemate:latest}"
BUILD_LOCAL=false
DOCKERFILE_PATH="docker/Dockerfile"
IMAGE_TAG=""

# Function to print colored messages
print_info() {
    printf "${BLUE}ℹ ${NC}%s\n" "$1"
}

print_success() {
    printf "${GREEN}✓${NC} %s\n" "$1"
}

print_warning() {
    printf "${YELLOW}⚠${NC} %s\n" "$1"
}

print_error() {
    printf "${RED}✗${NC} %s\n" "$1"
}

# Function to ask yes/no question
ask_yes_no() {
    local prompt="$1"
    local response
    while true; do
        printf "${YELLOW}?${NC} %s (y/n): " "$prompt"
        read -r response
        case "$response" in
            [Yy]* ) return 0;;
            [Nn]* ) return 1;;
            * ) echo "Please answer y or n.";;
        esac
    done
}


# Function to create .env file
create_env_file() {
    local env_file="$1"
    local anthropic_token=""
    local anthropic_url=""

    echo ""
    print_info "Anthropic API Configuration"
    echo ""

    # Prompt for ANTHROPIC_AUTH_TOKEN
    printf "${YELLOW}?${NC} Enter your Anthropic API token (press Enter to skip): "
    read -r anthropic_token

    # Prompt for ANTHROPIC_BASE_URL
    printf "${YELLOW}?${NC} Enter your Anthropic base URL (press Enter to skip): "
    read -r anthropic_url

    # Create .env file with user inputs
    cat > "$env_file" << EOF
# CodeMate Environment Configuration

# Optional: Default repository URL
# GIT_REPO_URL=

# Anthropic API Configuration
$(if [ -n "$anthropic_token" ]; then echo "ANTHROPIC_AUTH_TOKEN=$anthropic_token"; else echo "# ANTHROPIC_AUTH_TOKEN="; fi)
$(if [ -n "$anthropic_url" ]; then echo "ANTHROPIC_BASE_URL=$anthropic_url"; else echo "# ANTHROPIC_BASE_URL="; fi)
EOF
    print_success "Created $env_file"
}

# Function to create settings.json
create_settings_json() {
    local settings_file="$1"
    cat > "$settings_file" << 'EOF'
{
  "env": {
    "CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC": "1"
  },
  "attribution": {
    "commit": "",
    "pr": ""
  },
  "permissions": {
    "allow": [],
    "deny": []
  },
  "theme": "dark",
  "dangerouslyDisablePermissions": true,
  "defaultMode": "bypassPermissions"
}
EOF
    print_success "Created $settings_file"
}

# Function to update codemate script
update_script() {
    local script_path="$0"
    local temp_file="/tmp/codemate.tmp"
    local repo_url="https://raw.githubusercontent.com/BoringHappy/CodeMate/main/codemate"

    print_info "Updating codemate from repository..."

    # Download the latest version
    if command -v curl &> /dev/null; then
        if ! curl -fsSL "$repo_url" -o "$temp_file"; then
            print_error "Failed to download update"
            exit 1
        fi
    elif command -v wget &> /dev/null; then
        if ! wget -q "$repo_url" -O "$temp_file"; then
            print_error "Failed to download update"
            exit 1
        fi
    else
        print_error "Neither curl nor wget is available"
        exit 1
    fi

    # Verify the downloaded file is not empty
    if [ ! -s "$temp_file" ]; then
        print_error "Downloaded file is empty"
        rm -f "$temp_file"
        exit 1
    fi

    # Detect if running from global installation
    local script_real_path
    script_real_path=$(readlink -f "$script_path" 2>/dev/null || realpath "$script_path" 2>/dev/null || echo "$script_path")

    print_info "Updating codemate at: $script_real_path"

    # Replace the current script
    if ! mv "$temp_file" "$script_real_path"; then
        print_error "Failed to replace script"
        rm -f "$temp_file"
        exit 1
    fi

    # Make it executable
    chmod +x "$script_real_path"

    print_success "codemate has been updated successfully!"
    echo ""
    print_info "Please run the script again to use the new version"
    exit 0
}

# Function to setup CodeMate files
setup_codemate_files() {
    local current_dir="$(pwd)"
    local config_dir="$HOME/.codemate"

    print_info "Setting up CodeMate configuration..."
    echo ""

    # Create global config directory
    if [ ! -d "$config_dir/.claude" ]; then
        mkdir -p "$config_dir/.claude"
        print_success "Created global config directory: $config_dir/.claude"
    else
        print_info "Global config directory already exists: $config_dir/.claude"
    fi

    # Create .claude.json
    if [ ! -f "$config_dir/.claude.json" ]; then
        echo '{}' > "$config_dir/.claude.json"
        print_success "Created $config_dir/.claude.json"
    else
        print_warning "$config_dir/.claude.json already exists"
    fi

    # Create settings.json
    if [ ! -f "$config_dir/.claude/settings.json" ]; then
        create_settings_json "$config_dir/.claude/settings.json"
    else
        print_warning "$config_dir/.claude/settings.json already exists"
    fi

    # Create .env file in current directory (project-specific)
    if [ ! -f "$current_dir/.env" ]; then
        create_env_file "$current_dir/.env"
    else
        print_warning ".env already exists in current directory"
    fi

    echo ""
    print_success "Setup complete!"
    echo ""
    print_info "Configuration:"
    echo "  - Global config: $config_dir"
    echo "  - Project .env: $current_dir/.env"
    echo ""
    print_info "Next steps:"
    echo "  1. Edit $current_dir/.env to add ANTHROPIC_AUTH_TOKEN (if not set during setup)"
    echo "  2. Run: codemate --repo <repo-url> --branch <branch-name>"
    echo ""
    echo "Example:"
    echo "  codemate --repo https://github.com/user/repo.git --branch feature/my-feature"
    echo ""
}

# Function to build Docker image locally
build_docker_image() {
    local dockerfile_path="$1"
    local image_tag="$2"
    local build_context
    build_context="$(dirname "$dockerfile_path")"

    print_info "Building Docker image from local Dockerfile..."

    # Check if Dockerfile exists
    if [ ! -f "$dockerfile_path" ]; then
        print_error "Dockerfile not found at: $dockerfile_path"
        exit 1
    fi

    print_info "Using Dockerfile: $dockerfile_path"
    print_info "Image tag: $image_tag"
    print_info "Build context: $build_context"

    # Build the image
    if ! docker build -f "$dockerfile_path" -t "$image_tag" "$build_context"; then
        print_error "Failed to build Docker image"
        exit 1
    fi

    print_success "Docker image built successfully: $image_tag"
}

# Function to check prerequisites
check_prerequisites() {
    local missing_deps=()

    # Check Docker
    if ! command -v docker &> /dev/null; then
        missing_deps+=("docker")
    fi

    # Check gh CLI
    if ! command -v gh &> /dev/null; then
        missing_deps+=("gh (GitHub CLI)")
    fi

    # Check git
    if ! command -v git &> /dev/null; then
        missing_deps+=("git")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_error "Missing required dependencies:"
        for dep in "${missing_deps[@]}"; do
            echo "  - $dep"
        done
        echo ""
        echo "Please install the missing dependencies and try again."
        exit 1
    fi

    # Check if gh is authenticated (only if GITHUB_TOKEN not in .env)
    if [ -z "$GITHUB_TOKEN" ] && ! gh auth status &> /dev/null; then
        print_error "GitHub CLI is not authenticated"
        echo "Please run: gh auth login or set GITHUB_TOKEN"
        exit 1
    fi

    # Check Docker environment
    print_info "Checking Docker environment..."
    if ! docker info &> /dev/null; then
        print_error "Docker is not running or not accessible"
        echo ""
        echo "Possible solutions:"
        echo "  - Start Docker Desktop (macOS/Windows)"
        echo "  - Start Docker daemon: sudo systemctl start docker (Linux)"
        echo "  - Check Docker permissions: sudo usermod -aG docker \$USER (Linux)"
        echo "  - If using Colima: colima start"
        echo ""
        echo "After fixing, you may need to log out and back in for group changes to take effect."
        exit 1
    fi
    print_success "Docker is running"
}

# Function to run CodeMate container
run_codemate() {
    local current_dir="$(pwd)"
    local custom_mounts=("$@")
    local config_dir="$HOME/.codemate"

    # Check if global config exists
    if [ ! -d "$config_dir/.claude" ] || [ ! -f "$config_dir/.claude.json" ]; then
        print_error "CodeMate configuration not found"
        echo ""
        echo "Please run setup first:"
        echo "  codemate --setup"
        echo ""
        exit 1
    fi

    print_info "Using global configuration from: $config_dir"

    # Source .env file from current directory (project-specific)
    if [ -f "$current_dir/.env" ]; then
        set -a
        source "$current_dir/.env"
        set +a
    else
        print_warning "No .env file found in current directory"
        echo "Create one with: codemate --setup"
    fi

    # Get GitHub token from gh CLI if not already set in .env
    if [ -z "$GITHUB_TOKEN" ]; then
        GITHUB_TOKEN=$(gh auth token 2>/dev/null)
        if [ -z "$GITHUB_TOKEN" ]; then
            print_error "Failed to get GitHub token or gh is not authenticated"
            exit 1
        fi
    fi

    # Get git user info
    GIT_USER_NAME="${GIT_USER_NAME:-$(git config user.name)}"
    GIT_USER_EMAIL="${GIT_USER_EMAIL:-$(git config user.email)}"

    if [ -z "$GIT_USER_NAME" ] || [ -z "$GIT_USER_EMAIL" ]; then
        print_error "Git user name or email not configured"
        echo "Please set them in .env or run:"
        printf "  ${BLUE}git config --global user.name \"Your Name\"${NC}\n"
        printf "  ${BLUE}git config --global user.email \"your.email@example.com\"${NC}\n"
        exit 1
    fi

    # Extract repo name from git URL
    REPO_NAME=$(echo "$GIT_REPO_URL" | sed 's/\.git$//' | sed 's|.*/||')

    # Determine container name (include repo name to avoid conflicts between repos with same branch)
    local branch_for_name="${BRANCH_NAME:-main}"
    local repo_for_name=$(echo "$REPO_NAME" | sed 's/[^a-zA-Z0-9_-]/-/g')
    local branch_sanitized=$(echo "$branch_for_name" | sed 's/[^a-zA-Z0-9_-]/-/g')
    CONTAINER_NAME="codemate-${repo_for_name}-${branch_sanitized}"

    # Detect OS for network flag
    NETWORK_FLAG=""
    if [ "$(uname -s)" != "Darwin" ]; then
        NETWORK_FLAG="--network host"
    fi

    # Check if container is already running
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        print_success "Container $CONTAINER_NAME is running"
        print_info "Attaching zsh..."
        docker exec -it "$CONTAINER_NAME" zsh
        return
    fi

    # Create new container
    print_info "Creating new container $CONTAINER_NAME..."

    # Build volume mounts using global config
    local volume_mounts=(
        -v "$config_dir/.claude:/home/agent/.claude"
        -v "$config_dir/.claude.json:/home/agent/.claude.json"
    )

    # Mount skills directory if it exists in current directory
    if [ -d "$current_dir/skills" ]; then
        volume_mounts+=(-v "$current_dir/skills:/home/agent/.claude/skills")
        print_info "Mounting local skills directory"
    fi

    # Add custom volume mounts
    for mount in "${custom_mounts[@]}"; do
        if [ -n "$mount" ]; then
            volume_mounts+=(-v "$mount")
            print_info "Adding custom mount: $mount"
        fi
    done

    # Build env file flag if .env exists in current directory
    local env_file_flag=""
    if [ -f "$current_dir/.env" ]; then
        env_file_flag="--env-file $current_dir/.env"
    fi

    # Build docker run command
    local docker_cmd=(
        docker run --rm --name "$CONTAINER_NAME"
        --pull always
        $NETWORK_FLAG
        -it
        "${volume_mounts[@]}"
        $env_file_flag
        -e "GIT_REPO_URL=$GIT_REPO_URL"
        -e "UPSTREAM_REPO_URL=$UPSTREAM_REPO_URL"
        -e "BRANCH_NAME=$BRANCH_NAME"
        -e "PR_NUMBER=$PR_NUMBER"
        -e "PR_TITLE=$PR_TITLE"
        -e "ISSUE_NUMBER=$ISSUE_NUMBER"
        -e "QUERY=$QUERY"
        -e "GITHUB_TOKEN=$GITHUB_TOKEN"
        -e "GIT_USER_NAME=$GIT_USER_NAME"
        -e "GIT_USER_EMAIL=$GIT_USER_EMAIL"
        -e "TMPDIR=/home/agent/.claude/tmp"
        -w "/home/agent/$REPO_NAME"
        "$CODEMATE_IMAGE"
    )

    "${docker_cmd[@]}"
}

# Function to show usage
show_usage() {
    cat << EOF
CodeMate - Docker-based Claude Code environment

Usage: codemate [OPTIONS]

Options:
  --setup              Run setup to create configuration files
  --update             Update codemate to the latest version from repository
  --branch NAME        Branch name to work on
  --pr NUMBER          Existing PR number to work on
  --pr-title TITLE     PR title (optional)
  --issue NUMBER       GitHub issue number to work on (creates branch issue-NUMBER)
  --query QUERY        Initial query to send to Claude after startup
  --repo URL           Git repository URL (can be your own repo or a fork)
  --upstream URL       Upstream repository URL (optional, for fork-based workflows)
  --mount PATH:PATH    Custom volume mount (can be used multiple times)
  --image IMAGE        Docker image to use (default: ghcr.io/boringhappy/codemate:latest)
                       Note: Ignored when --build is used
  --build              Build Docker image from local Dockerfile
  -f, --dockerfile PATH  Path to Dockerfile (default: docker/Dockerfile, requires --build)
  --tag TAG            Image tag for local build (default: codemate:local)
                       Note: Only works with --build. To use a pre-built image, use --image instead
  --help               Show this help message

Environment Variables:
  GIT_REPO_URL         Repository URL (defaults to current repo's remote)
  UPSTREAM_REPO_URL    Upstream repository URL (for fork workflows)
  BRANCH_NAME          Branch to work on
  PR_NUMBER            Existing PR number
  PR_TITLE             PR title
  ISSUE_NUMBER         GitHub issue number
  QUERY                Initial query to send to Claude after startup
  GITHUB_TOKEN         GitHub personal access token
  GIT_USER_NAME        Git commit author name
  GIT_USER_EMAIL       Git commit author email
  CODEMATE_IMAGE       Docker image to use (default: ghcr.io/boringhappy/codemate:latest)
  SLACK_WEBHOOK        Slack Incoming Webhook URL for notifications when Claude stops

Examples:
  # First time setup
  codemate --setup

  # Update to latest version
  codemate --update

  # Run with custom repo
  codemate --repo https://github.com/user/repo.git --branch feature/xyz

  # Run with branch name
  codemate --branch feature/my-feature

  # Run with existing PR
  codemate --pr 123

  # Run with GitHub issue
  codemate --issue 456

  # Fork-based workflow examples
  # Open-source contribution: your fork → maintainer's repo
  codemate --repo https://github.com/yourname/project.git --upstream https://github.com/maintainer/project.git --branch fix-bug
  codemate --repo https://github.com/yourname/project.git --upstream https://github.com/maintainer/project.git --issue 789

  # Run with custom volume mounts
  codemate --branch feature/xyz --mount /local/path:/container/path
  codemate --branch feature/xyz --mount ~/data:/data --mount ~/config:/config

  # Run with custom image
  codemate --branch feature/xyz --image ghcr.io/boringhappy/codemate:v1.0.0

  # Build and run from local Dockerfile
  codemate --build --branch feature/xyz

  # Build with custom Dockerfile path and tag
  codemate --build -f ./custom/Dockerfile --tag my-codemate:v1 --branch feature/xyz

  # Run with initial query
  codemate --branch feature/xyz --query "Please review the code and fix any issues"

EOF
}

# Main script logic
main() {
    local force_setup=false
    local current_dir="$(pwd)"
    local custom_mounts=()

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --setup)
                force_setup=true
                shift
                ;;
            --update)
                update_script
                ;;
            --branch)
                if [ -z "$2" ]; then
                    print_error "--branch requires a branch name"
                    show_usage
                    exit 1
                fi
                BRANCH_NAME="$2"
                shift 2
                ;;
            --pr)
                if [ -z "$2" ]; then
                    print_error "--pr requires a PR number"
                    show_usage
                    exit 1
                fi
                PR_NUMBER="$2"
                shift 2
                ;;
            --pr-title)
                if [ -z "$2" ]; then
                    print_error "--pr-title requires a title"
                    show_usage
                    exit 1
                fi
                PR_TITLE="$2"
                shift 2
                ;;
            --issue)
                if [ -z "$2" ]; then
                    print_error "--issue requires an issue number"
                    show_usage
                    exit 1
                fi
                ISSUE_NUMBER="$2"
                shift 2
                ;;
            --query)
                if [ -z "$2" ]; then
                    print_error "--query requires a query string"
                    show_usage
                    exit 1
                fi
                QUERY="$2"
                shift 2
                ;;
            --repo)
                if [ -z "$2" ]; then
                    print_error "--repo requires a repository URL"
                    show_usage
                    exit 1
                fi
                GIT_REPO_URL="$2"
                shift 2
                ;;
            --upstream)
                if [ -z "$2" ]; then
                    print_error "--upstream requires a repository URL"
                    show_usage
                    exit 1
                fi
                UPSTREAM_REPO_URL="$2"
                shift 2
                ;;
            --mount)
                custom_mounts+=("$2")
                shift 2
                ;;
            --image)
                CODEMATE_IMAGE="$2"
                shift 2
                ;;
            --build)
                BUILD_LOCAL=true
                shift
                ;;
            -f|--dockerfile)
                DOCKERFILE_PATH="$2"
                shift 2
                ;;
            --tag)
                IMAGE_TAG="$2"
                shift 2
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Check if configuration files exist
    local needs_setup=false
    local config_dir="$HOME/.codemate"
    if [ ! -d "$config_dir/.claude" ] || \
       [ ! -f "$config_dir/.claude.json" ] || \
       [ ! -f "$config_dir/.claude/settings.json" ]; then
        needs_setup=true
    fi

    # If setup is needed or forced, ask user
    if [ "$force_setup" = true ] || [ "$needs_setup" = true ]; then
        echo ""
        print_info "CodeMate Setup"
        echo ""

        if [ "$needs_setup" = true ]; then
            print_warning "Global configuration not found"
            echo "The following will be created:"
            echo "  1. Global config directory: $config_dir/.claude"
            echo "  2. Claude config file: $config_dir/.claude.json"
            echo "  3. Settings file: $config_dir/.claude/settings.json"
            echo "  4. Project .env file: $current_dir/.env"
            echo ""
        fi

        if ask_yes_no "Create CodeMate configuration files?"; then
            setup_codemate_files
            exit 0
        else
            print_info "Setup cancelled"
            exit 0
        fi
    fi

    # Check prerequisites
    check_prerequisites

    # Handle local build if requested
    if [ "$BUILD_LOCAL" = true ]; then
        # Set default tag if not specified
        if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG="codemate:local"
        fi

        # Build the image
        build_docker_image "$DOCKERFILE_PATH" "$IMAGE_TAG"

        # Use the locally built image
        CODEMATE_IMAGE="$IMAGE_TAG"
    fi

    # Handle issue-based workflow
    if [ -n "$ISSUE_NUMBER" ]; then
        # Set branch name based on issue number
        BRANCH_NAME="issue-${ISSUE_NUMBER}"

        # Check if branch already exists
        if git show-ref --verify --quiet refs/heads/issue-${ISSUE_NUMBER} 2>/dev/null; then
            print_warning "Branch issue-${ISSUE_NUMBER} already exists"
        fi

        # Determine which repo to read the issue from (upstream if set, otherwise fork/origin)
        ISSUE_REPO_URL="${UPSTREAM_REPO_URL:-$GIT_REPO_URL}"

        # Extract repo owner and name for issue URL
        if [ -n "$ISSUE_REPO_URL" ]; then
            # Remove .git suffix and extract owner/repo
            REPO_PATH=$(echo "$ISSUE_REPO_URL" | sed 's/\.git$//' | sed 's|.*github\.com[:/]||')
            ISSUE_URL="https://github.com/${REPO_PATH}/issues/${ISSUE_NUMBER}"

            # Set initial query if not already set
            if [ -z "$QUERY" ]; then
                QUERY="Please use /issue:read-issue skill to read and address issue #${ISSUE_NUMBER} (${ISSUE_URL})"
            fi
        fi

        print_info "Working on issue #${ISSUE_NUMBER} using branch: ${BRANCH_NAME}"
    fi

    # Validate required parameters
    if [ -z "$BRANCH_NAME" ] && [ -z "$PR_NUMBER" ] && [ -z "$ISSUE_NUMBER" ]; then
        print_error "Either --branch, --pr, or --issue must be specified"
        echo ""
        show_usage
        exit 1
    fi

    if [ -z "$GIT_REPO_URL" ]; then
        print_error "GIT_REPO_URL not set"
        echo ""
        echo "The repository URL can be provided in three ways (in priority order):"
        echo "  1. Use --repo option: codemate --repo https://github.com/user/repo.git --branch xyz"
        echo "  2. Set GIT_REPO_URL in .env file"
        echo "  3. Run from a git repository directory (auto-detects remote origin)"
        echo ""
        exit 1
    fi

    # Run CodeMate
    run_codemate "${custom_mounts[@]}"
}

# Run main function
main "$@"

